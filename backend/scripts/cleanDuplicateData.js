const FirebaseService = require('../services/firebaseService');
const AutoAttendanceService = require('../services/autoAttendanceService');
const moment = require('moment-timezone');


async function cleanExistingDuplicates() {
    try {
        console.log('Starting cleanup of existing duplicate data in Firebase...');
        
        
        moment.tz.setDefault('Asia/Jakarta');
        
        
        const dates = [];
        for (let i = 0; i <= 7; i++) {
            const date = moment().subtract(i, 'days').format('YYYY-MM-DD');
            dates.push(date);
        }
        
        console.log(`Cleaning dates: ${dates.join(',')}`);
        
        const autoService = new AutoAttendanceService();
        let totalCleaned = 0;
        
        for (const date of dates) {
            console.log(`\n Processing date: ${date}`);
            
            const result = await autoService.cleanDuplicateAttendance(date);
            
            if (result.success) {
                console.log(`${date}: Removed ${result.duplicatesRemoved} duplicates from ${result.totalRecords} records`);
                totalCleaned += result.duplicatesRemoved;
            } else {
                console.log(`${date}: Failed to clean - ${result.error}`);
            }
            
            
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        console.log(`\n Cleanup completed! Total duplicates removed: ${totalCleaned}`);
        
        
        console.log('\n Final check for today\'s data...');
        const today = moment().format('YYYY-MM-DD');
        
        const todayRecords = await FirebaseService.getDocuments('attendance', [
            { field: 'tanggal', operator: '==', value: today }
        ]);
        
        
        const memberGroups = {};
        todayRecords.forEach(record => {
            const keys = [record.nim, record.anggotaId, record.memberId, record.idRfid].filter(Boolean);
            const memberKey = keys[0] || record.nama;
            
            if (!memberGroups[memberKey]) {
                memberGroups[memberKey] = [];
            }
            memberGroups[memberKey].push(record);
        });
        
        let remainingDuplicates = 0;
        Object.entries(memberGroups).forEach(([memberKey, records]) => {
            if (records.length > 1) {
                remainingDuplicates += records.length - 1;
                console.log(`${memberKey} still has ${records.length} records:`);
                records.forEach(r => {
                    console.log(`- Status: ${r.status}, AutoGenerated: ${r.autoGenerated}, JamDatang: ${r.jamDatang}`);
                });
            }
        });
        
        if (remainingDuplicates === 0) {
            console.log('No remaining duplicates found!');
        } else {
            console.log(`Found ${remainingDuplicates} remaining duplicates that may need manual review`);
        }
        
    } catch (error) {
        console.error('Error during cleanup:', error);
    } finally {
        process.exit(0);
    }
}


cleanExistingDuplicates();
